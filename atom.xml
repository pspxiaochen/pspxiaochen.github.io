<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>发条晨</title>
  
  <subtitle>愿我走出半生，归来仍是少年</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pspxiaochen.club/"/>
  <updated>2018-07-17T09:40:05.548Z</updated>
  <id>https://pspxiaochen.club/</id>
  
  <author>
    <name>pspxiaochen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红黑树的一些简单介绍</title>
    <link href="https://pspxiaochen.club/rb-tree/"/>
    <id>https://pspxiaochen.club/rb-tree/</id>
    <published>2018-07-16T10:03:07.000Z</published>
    <updated>2018-07-17T09:40:05.548Z</updated>
    
    <content type="html"><![CDATA[<p>红-黑树是基于二叉搜索树的，如果对二叉搜索树不了解，可以先看看：<br><a href="https://blog.csdn.net/eson_15/article/details/51138663" rel="external nofollow noopener noreferrer" target="_blank">二叉搜索树</a></p><h1 id="红黑树的主要规则："><a href="#红黑树的主要规则：" class="headerlink" title="红黑树的主要规则："></a>红黑树的主要规则：</h1><p>1.每个节点不是红色就是黑色。<br>2.根节点一定是黑色的。<br>3.如果一个节点是红色的，那么它的两个子节点都必须是黑色的。（反之不一定）<br>4.从根节点到每个叶子节点或者空子节点的路径，都必须包含相同数目的黑色节点。</p><p>补充：红黑树没有AVL树那么平衡。它有它自己的平衡方法，满足了上面4条就叫平衡了。<br>      如果添加或者删除节点之后打破了平衡，那么通过改变节点颜色，左旋，右旋可以使红黑树恢复平衡。</p><p>具体的看这个链接里的讲解：<a href="https://blog.csdn.net/eson_15/article/details/51144079" rel="external nofollow noopener noreferrer" target="_blank">红黑树</a></p>]]></content>
    
    <summary type="html">
    
      总结一下红黑树，只是总结。。。。
    
    </summary>
    
      <category term="数据结构" scheme="https://pspxiaochen.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树的删除</title>
    <link href="https://pspxiaochen.club/search-tree/"/>
    <id>https://pspxiaochen.club/search-tree/</id>
    <published>2018-07-14T02:40:29.000Z</published>
    <updated>2018-07-14T05:35:36.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种情况："><a href="#三种情况：" class="headerlink" title="三种情况："></a>三种情况：</h1><p>&emsp;&emsp;删除节点时二叉搜索树中最复杂的操作，但是删除节点在很多树的应用中又非常重要，所以详细研究并总结下特点。删除节点要从查找要删的节点开始入手，首先找到节点，这个要删除的节点可能有三种情况需要考虑：<br>1.该节点是叶子结点，没有孩子结点了。<br>2.该节点有一个孩子节点。<br>3.该节点有两个孩子节点。</p><p>第一种最简单，第二种也还是比较简单的，第三种就相当复杂了。下面分析这三种删除情况：</p><h1 id="第一种情况："><a href="#第一种情况：" class="headerlink" title="第一种情况："></a>第一种情况：</h1><p>&emsp;&emsp;要删除叶子节点，只需要改变该节点的父节点对应子字段的值即可，由指向要删除的节点改为null就可以了。垃圾回收器会自动回收叶节点，不需要自己手动删掉；</p><h1 id="第二种情况："><a href="#第二种情况：" class="headerlink" title="第二种情况："></a>第二种情况：</h1><p>&emsp;&emsp;当要删除的节点有一个子节点时，这个将要删除的节点只有2个连接：连向父节点和连向它唯一的子节点。我们需要间断这些连接，把它的子节点直接连接到它的父节点上即可，如果被删除的节点是父节点的左子节点，那么我就把要删除节点的子节点连接到被删除节点父节点的左子节点就行。右子节点同理。</p><h1 id="第三种情况："><a href="#第三种情况：" class="headerlink" title="第三种情况："></a>第三种情况：</h1><p>&emsp;&emsp;第三种情况是最复杂的。如果要删除有两个子节点的节点，就不能只用它的一个子节点代替它。<br>因此需要考虑另一种方法，寻找它的中序后继来代替该节点。那么如何找后继节点呢？<br>&emsp;&emsp;首先得找到要删除的节点的右子节点，它的关键字值一定比待删除节点的大。然后转到待删除节点右子节点的左子节点那里（如果有的话），然后到这个左子节点的左子节点，以此类推，顺着左子节点的路径一直向下找，这个路径上的最后一个左子节点就是待删除节点的后继。如果待删除节点的右子节点没有左子节点，那么这个右子节点本身就是后继。（后继节点就是比这个要删除节点第一个大的数）。<br>&emsp;&emsp;找到后继节点我们就可以开始删除了。</p><h2 id="第一种情况：后继节点是需要删除节点的右节点的左后代，这种情况要执行以下四个步骤："><a href="#第一种情况：后继节点是需要删除节点的右节点的左后代，这种情况要执行以下四个步骤：" class="headerlink" title="第一种情况：后继节点是需要删除节点的右节点的左后代，这种情况要执行以下四个步骤："></a>第一种情况：后继节点是需要删除节点的右节点的左后代，这种情况要执行以下四个步骤：</h2><p>1.把后继的右子节点给后继节点的父节点的左孩子（leftChild)字段。<br>2.把要删除节点的右节点给后继节点的右孩子(rightChild)字段。<br>3.把待删除节点从它父节点的leftChild或rightChild字段删除，把这个字段置为后继；(如果删除的是左孩子字段就把左孩子字段设置成后继）。<br>4.将后继的leftChild字段置为待删除节点的左子节点。</p><h2 id="第二种情况：如果后继节点就是待删除节点的右子节点（这个后继节点肯定没有左孩子），这种情况比较简单，只需要把后继为根的子树移动到删除节点的位置即可。"><a href="#第二种情况：如果后继节点就是待删除节点的右子节点（这个后继节点肯定没有左孩子），这种情况比较简单，只需要把后继为根的子树移动到删除节点的位置即可。" class="headerlink" title="第二种情况：如果后继节点就是待删除节点的右子节点（这个后继节点肯定没有左孩子），这种情况比较简单，只需要把后继为根的子树移动到删除节点的位置即可。"></a>第二种情况：如果后继节点就是待删除节点的右子节点（这个后继节点肯定没有左孩子），这种情况比较简单，只需要把后继为根的子树移动到删除节点的位置即可。</h2><p>样例和源码看这里<br><a href="https://blog.csdn.net/eson_15/article/details/51138663" rel="external nofollow noopener noreferrer" target="_blank">二叉搜索树</a></p>]]></content>
    
    <summary type="html">
    
      介绍一下二叉搜索树怎么删除节点。
    
    </summary>
    
      <category term="数据结构" scheme="https://pspxiaochen.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>关于B树的一些简单的总结</title>
    <link href="https://pspxiaochen.club/btree/"/>
    <id>https://pspxiaochen.club/btree/</id>
    <published>2018-07-09T01:16:51.000Z</published>
    <updated>2018-07-09T02:50:14.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>&emsp;&emsp;先说一下，B-树，B树，是一个东西。B树和普通的平衡二叉树不同的是B树属于多叉树又名平衡多路查找树（查找的路径不只有2条），数据库索引技术里大量使用了B树。</p><h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>&emsp;&emsp;（1）树中的每个节点最多拥有m个子节点且m&gt;=2,空树除外（m阶代表一个树的节点最多有多少条查找路径，m阶=m路，当m=2则是平衡二叉树，当m=3时叫3阶B树）<br>&emsp;&emsp;（2）除了根节点以外，每个节点的关键字数量大于等于 ceil(m/2)-1个 (ceil向上取整的函数)，小于等于m-1个，非根节点关键字必须大于等于2。（关键字在节点中）<br>&emsp;&emsp;（3）所有叶子节点均在同一层，叶子节点除了包含了关键字和关键字记录的指针外也有只想其他子节点的指针，只不过其地址都为null.<br>&emsp;&emsp;（4）如果一个非叶子节点有N个子节点，则该结点的关键字个数等于N-1。（有3个子节点说明有3条路径，可以理解成2个关键字把一条数轴分成了3段，这每一段代表一条路径）。<br>&emsp;&emsp;（5）所有节点关键字是按递增次序排列，并遵循左小右大原则。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><img src="http://wx2.sinaimg.cn/mw690/72fdc620ly1ft3elepdnuj20jv08t0t8.jpg" alt="此处输入图片的描述"></p><h2 id="查找流程"><a href="#查找流程" class="headerlink" title="查找流程"></a>查找流程</h2><p> 如上图我要从上图中找到E字母<br> （1）获取根节点的关键字进行比较，当前根节点关键字为M，E要小于M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</p><p>（2）拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</p><p>（3）拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</p><h2 id="插入规则"><a href="#插入规则" class="headerlink" title="插入规则"></a>插入规则</h2><p>（1）当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）-1小于等于5-1（关键字数小于cei(5/2) -1就要进行节点合并，大于5-1就要进行节点拆分,非根节点关键字数&gt;=2）；<br>（2）满足节点本身比左边节点大，比右边节点小的排序规则;</p><h2 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h2><p>（1）当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于cei(5/2)-1，小于等于5-1，非根节点关键字数大于2；</p><p>（2）满足节点本身比左边节点大，比右边节点小的排序规则;</p><p>（3）关键字数小于二时先从子节点取，取中间值往父节点放，子节点没有符合条件时就向向父节点取；</p><p>基本的东西就这些，如果还需要进一步的学习，可以看这篇文章<br><a href="https://blog.csdn.net/v_JULY_v/article/details/6530142/" rel="external nofollow noopener noreferrer" target="_blank">从B树、B+树、B*树谈到R 树</a></p>]]></content>
    
    <summary type="html">
    
      考研的时候复习到B树，当时感觉好难，时间不怎么够了，就放弃了。前几天复习了一下B树，现在总结一下。
    
    </summary>
    
      <category term="数据结构" scheme="https://pspxiaochen.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表的一些总结</title>
    <link href="https://pspxiaochen.club/hash/"/>
    <id>https://pspxiaochen.club/hash/</id>
    <published>2018-07-07T04:27:00.000Z</published>
    <updated>2018-07-07T09:12:28.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>&emsp;&emsp;理想的散列表数据结构只不过是一个包含有关键字的具有固定大小的数组。我们把表的大小记作Tablesize.<strong>（最好让表的大小是一个质数）</strong>每一个关键字被映射到从0到TableSize-1这个范围中的某个数，并且被放到适当的单元中。这个映射就叫做<strong>散列函数</strong>，理想情况下它应该运算简单并且应该保证任何两个不同的关键字映射到不同的单元。不过这是不可能的，因为单元的数目是有限的，而关键字实际上是用不完的。<br>&emsp;&emsp;这就是散列的基本想法。剩下的问题则是要选择一个函数，决定当关键字散列到同一个值的时候（称为冲突）应该做什么。</p><h1 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h1><p>&emsp;&emsp;如果当一个元素被插入时另一个元素已经存在（散列值相同），那么就产生一个冲突，这个冲突需要消除。我讲介绍其中最简单的2种方法：分离链接法和开放地址法。</p><h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>&emsp;&emsp;解决冲突的第一种方法通常叫做分离链接法，其做法是将散列到同一个值的所有元素保留到一个表中。为了方法起见，这些表都有表头。也就是数组里存了一个链表，为了以后删除元素方便，每个链表都有一个表头。如下图所示：<img src="http://wx3.sinaimg.cn/mw690/72fdc620ly1ft1ciiz3n2j20u014076v.jpg" alt="此处输入图片的描述"></p><p>&emsp;&emsp;分离链接法的缺点是需要指针，由于给新单元分配地址需要时间，一次这就导致算法的速度多少有些慢，同时算法实际上还要求对另一种数据结构的实现。</p><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>&emsp;&emsp;开放定址散列法是另外一种不同链表解决冲突的方法。在这个方法中，如果有冲突发生，那么就要尝试选择另外的单元，直到找出空的单元为止。更一般的，单元$h_0(X),h_1(X),h_2(X)$等等，相继被试选，其中<br>$h_i(X)=(Hash(X)+F(i))$ mod TableSize 函数F是冲突解决方法。 一般来说，对开放定址散列算法来说，装填因子应该低于$\lambda$=0.5。接下来介绍3个通常解决冲突的方法。</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>&emsp;&emsp;在线性探测法中，函数F是i的线性函数，典型情形是F(i)=i。这相当于逐个探测每个单元（必要时可以绕回）以查找出一个空单元。 如果表可以有多于一半被填满的话，那么线性探测就不是一个好办法。</p><h3 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h3><p>&emsp;&emsp;平方探测法是消除线性探测中一次聚集问题的冲突解决方法。平方探测就是冲突函数为二次函数的探测方法。流行的选择是$F(i)=i^2$<br>&emsp;&emsp;对于线性探测，让元素几乎填满散列表并不是一个好的主意，因此测试表的性能会降低。对于平方探测情况甚至更糟：一旦表被填满超过一半，当表的大小不是质数时甚至在表被填满一半之前，就不能保证一次找到一个空单元了。这是因为最多有表的一半可以用作解决冲突的备选位置。<br>&emsp;&emsp;对于这种情况，我们可以使用<strong>再散列</strong>,就是建立另外一个大约两倍大的表（并且使用一个相关的新散列函数），扫描这个那个原始散列表，计算每个（未删除的）元素的新散列值并将其插入到新表。<br>&emsp;&emsp;在散列可以用平方探测以多种方法实现。一种做法是只要表满到一半就再散列。另一种极端的方法是只有当插入失败时才再散列。第三种是当表到达某一个装填因子时进行再散列。由于随着装填因子的增加表的性能的确有下降，因此第三种可能是最好的策略。</p><h3 id="双散列"><a href="#双散列" class="headerlink" title="双散列"></a>双散列</h3><p>&emsp;&emsp;对于双散列，一种流行的选择是$F(i)=i * hash(x)$.这个方法如果hash函数选择的不好将会是灾难性的。比如X=99，hash(x) = x mod 9.因此，函数一定不要算得0.</p>]]></content>
    
    <summary type="html">
    
      今天粗略的看了一下哈希表，简单的记录一下，如果以后有需要再补充。
    
    </summary>
    
      <category term="数据结构" scheme="https://pspxiaochen.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>这是一个天大的秘密</title>
    <link href="https://pspxiaochen.club/test/"/>
    <id>https://pspxiaochen.club/test/</id>
    <published>2018-07-05T04:27:00.000Z</published>
    <updated>2018-07-05T09:52:39.552Z</updated>
    
    <content type="html"><![CDATA[<p>其实什么都没有，这只是一个测试而已。</p>]]></content>
    
    <summary type="html">
    
      这个秘密只能我一个人知道，任何人都不应该知道。
    
    </summary>
    
      <category term="life" scheme="https://pspxiaochen.club/categories/life/"/>
    
    
      <category term="秘密" scheme="https://pspxiaochen.club/tags/%E7%A7%98%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>线性回归与最小二乘法</title>
    <link href="https://pspxiaochen.club/costfunction/"/>
    <id>https://pspxiaochen.club/costfunction/</id>
    <published>2018-07-03T04:27:00.000Z</published>
    <updated>2018-07-05T10:20:04.207Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我们假设正确的结果y和我们的预测的输出函数有如下关系：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$y^{(i)} = \theta^Tx^{(i)} + \epsilon^{(i)}$</p><p>在这里$\theta^Tx^{(i)}$为我们的预测函数，$\epsilon^{(i)}$是和真实值的误差。<br>因为每个样本都是独立的，因此误差直接也是独立的。所以我们假设$\epsilon^{(i)}$服从期望是0（我们希望没有误差）,方差是$\sigma^2$的高斯分布，记作$\epsilon^{(i)}\sim N(0,\sigma^2)$,而高斯分布的概率密度函数为：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$P(x)=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x-\mu)^2}{2\sigma^2})$<br>&emsp;&emsp;将误差带入上面的式子得：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$P(\epsilon^{(i)})=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(\epsilon^{(i)})^2}{2\sigma^2})$</p><p>因为我们假设$\epsilon^{(i)}$服从期望是0（我们希望没有误差）,方差是$\sigma^2$的高斯分布。所以还可以假设$y^{(i)}$是服从期望是里$\theta^Tx^{(i)}$，方差为$\sigma^2$的高斯分布，在给定 x(i)且参数为 θ的情况下，记作：$y^{(i)}\sim N(\theta^Tx^{(i)},\sigma^2)$,所以我们可以将上面的式子改写为：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$P(y^{(i)}|x^{(i)};\theta)=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})$</p><p>因为在我们的样本中，y(i) 已经给定了，我们需要找到一个参数 θ，使得我们最有可能去得到 y(i)的分布。我们想要估计其中的未知参数θ。由此我们可以想到一个非常常用的参数估计方法—极大似然估计。<br>关于极大似然估计我推荐知乎的2篇文章，讲的浅显易懂。<br><a href="https://zhuanlan.zhihu.com/p/32568242" rel="external nofollow noopener noreferrer" target="_blank">似然函数与极大似然估计</a><br><a href="https://zhuanlan.zhihu.com/p/26614750" rel="external nofollow noopener noreferrer" target="_blank">一文搞懂极大似然估计</a></p><p>接着刚才，我们使用极大似然估计后可写成：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$L(\theta)=\prod_{i=1}^mP(y^{(i)}|x^{(i)};\theta) $</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$L(\theta)=\prod_{i=1}^m\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})$</p><p>因为是极大似然估计，所以我们希望$L(\theta)$要尽可能的大。所以我们对上面的式子取对数，因为对数不改变函数的单调性。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$L(\theta)=\sum_{i=1}^m log\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$=mlog\frac{1}{\sqrt{2\pi}\sigma}+\sum_{i=1}^m -\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2}$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$=mlog\frac{1}{\sqrt{2\pi}\sigma}-\sum_{i=1}^m \frac{1}{2\sigma^2}*(y^{(i)}-\theta^Tx^{(i)})^2$</p><p>为了使$L(\theta)$要尽可能的大，我们就需要让$J(\theta)=\frac{1}{2}*(y^{(i)}-\theta^Tx^{(i)})^2$尽量的小，所以就有了平方损失函数，可以看到是一模一样的。J(θ) 即为此线性回归的cost function。由此我们可以非常自然地推导出为什么线性回归中的cost function是使用最小二乘法。<br>接下来就是求解过程，常用的就是梯度下降，如果想知道为什么用梯度下降，请看这篇<br><a href="https://www.pspxiaochen.club/2018-05-24-GD/" rel="external nofollow noopener noreferrer" target="_blank">我自己理解的梯度下降原理</a></p>]]></content>
    
    <summary type="html">
    
      当初学习线性回归的时候，知道了要优化损失函数，使损失函数要尽量的小。而损失函数就直接拿平方损失函数直接用，完全不知道为什么要用这个损失函数，慢慢的对这个问题感到好奇，查了资料才发现，确实是有一定道理的，我现在就来总结一下。
    
    </summary>
    
      <category term="机器学习" scheme="https://pspxiaochen.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="线性回归" scheme="https://pspxiaochen.club/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>25周岁生日</title>
    <link href="https://pspxiaochen.club/birthday/"/>
    <id>https://pspxiaochen.club/birthday/</id>
    <published>2018-06-29T11:27:00.000Z</published>
    <updated>2018-06-30T04:31:13.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天是25岁生日，祝我生日快乐，下午接了一个团购鞋子，真是讽刺。"><a href="#今天是25岁生日，祝我生日快乐，下午接了一个团购鞋子，真是讽刺。" class="headerlink" title="今天是25岁生日，祝我生日快乐，下午接了一个团购鞋子，真是讽刺。"></a>今天是25岁生日，祝我生日快乐，下午接了一个团购鞋子，真是讽刺。</h1>]]></content>
    
    <summary type="html">
    
      祝我生日快乐。
    
    </summary>
    
      <category term="life" scheme="https://pspxiaochen.club/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习之交叉验证</title>
    <link href="https://pspxiaochen.club/cross-validation/"/>
    <id>https://pspxiaochen.club/cross-validation/</id>
    <published>2018-06-29T02:27:00.000Z</published>
    <updated>2018-06-29T03:32:36.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交叉验证的基本思想"><a href="#交叉验证的基本思想" class="headerlink" title="交叉验证的基本思想"></a>交叉验证的基本思想</h1><p>&emsp;&emsp; 交叉验证的基本想法是重复的使用数据；把给定数据进行切分，将切分的数据集组合为训练集与测试集，再次基础上反复地进行训练、测试、以及模型选择。</p><h2 id="简单的交叉验证"><a href="#简单的交叉验证" class="headerlink" title="简单的交叉验证"></a>简单的交叉验证</h2><p>1、首先随机得将已给数据分为两部分，一部分作为训练集，一部分作为测试集。（一般是73分）<br>2、然后用训练集在各种条件下（比如不同的参数）训练模型，从而得到不同的模型；<br>3、在测试集上评价各个模型的测试误差，选出测试误差最小的模型。<br>优点：由于测试集和训练集是分开的，就避免了过拟合现象</p><h2 id="k折交叉验证"><a href="#k折交叉验证" class="headerlink" title="k折交叉验证"></a>k折交叉验证</h2><p>1.首先将训练数据平均切分成k份，每一份互不相交且大小一样。<br>2.用k-1个子集进行训练模型，用余下的那一个作为预测。<br>3.将2这一过程对可能的k种选择重复进行。<br>4.最后选出k次测评中测试误差最小的。、<br>优点：这个方法充分利用了所有样本。但计算比较繁琐，需要训练k次，测试k次。</p><h2 id="留一法"><a href="#留一法" class="headerlink" title="留一法"></a>留一法</h2><p>留一法就是每次只留下一个样本做测试集，其它样本做训练集，如果有k个样本，则需要训练k次，测试k次。<br>优点：留一发计算最繁琐，但样本利用率最高。适合于小样本的情况。</p>]]></content>
    
    <summary type="html">
    
      昨天面试的不太好，面试官问到了几种交叉验证可以解决的问题，没有答上来，今天来总结一下。
    
    </summary>
    
      <category term="机器学习" scheme="https://pspxiaochen.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="交叉验证" scheme="https://pspxiaochen.club/tags/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>求余和取模傻傻分不清</title>
    <link href="https://pspxiaochen.club/rem-and-mod/"/>
    <id>https://pspxiaochen.club/rem-and-mod/</id>
    <published>2018-06-27T13:27:00.000Z</published>
    <updated>2018-06-27T12:21:38.761Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;通常情况下取模运算(mod)和求余(rem)运算被混为一谈，因为在大多数的编程语言里，都用’%’符号表示取模或者求余运算。在这里要提醒大家要十分注意当前环境下’%’运算符的具体意义，因为在有负数存在的情况下，两者的结果是不一样的。<br>&emsp;&emsp;假设有整数a和b，取模或者求余运算的方法都是（1）c=a/b (2)r=a-c*b<br>&emsp;&emsp;求模运算和求余运算在第一步不同,取余运算在计算商值向0方向舍弃小数位,取模运算在计算商值向负无穷方向舍弃小数位.<br>&emsp;&emsp;在C中 %是取余，mod是取模。<br>&emsp;&emsp;在Python中%就是取模。</p><h1 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h1><p>如果a=3 b=-4<br>3/(-4)等于-0.75<br>在取余运算时候商值向0方向舍弃小数位为0<br>在取模运算时商值向负无穷方向舍弃小数位为-1<br>所以<br>3rem(-4) = 3<br>3mod(-4) = -1<br>希望这次可以记住。</p>]]></content>
    
    <summary type="html">
    
      之前总分不清楚，希望这次可以一直记住。
    
    </summary>
    
      <category term="笔试" scheme="https://pspxiaochen.club/categories/%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="mod" scheme="https://pspxiaochen.club/tags/mod/"/>
    
  </entry>
  
  <entry>
    <title>kd树-第一次面试的痛</title>
    <link href="https://pspxiaochen.club/kd-tree/"/>
    <id>https://pspxiaochen.club/kd-tree/</id>
    <published>2018-06-26T13:27:00.000Z</published>
    <updated>2018-06-27T02:54:08.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是KD树"><a href="#什么是KD树" class="headerlink" title="什么是KD树"></a>什么是KD树</h1><p>&emsp;&emsp;kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd树是二叉树，表示对k维空间的一个划分。构造kd树相当于不断的用垂直于坐标轴的超平面将K维空间切分，构成一系列的k维超矩形区域。kd树的每个节点对应于一个K维超矩形区域。</p><h1 id="构建KD树"><a href="#构建KD树" class="headerlink" title="构建KD树"></a>构建KD树</h1><p>输入：K维空间数据集，样本数为N。$x_i = (x_i^{(1)},x_i^{(2)},x_i^{(3)}….x_i^{(k)})^T$<br>输出：KD树<br>&emsp;&emsp;(1)开始：构造根节点，根节点包含了K维空间的超矩形区域。<br>&emsp;&emsp;选择$x^{(1)}$作为第一个切分的维度，找到$x^{(1)}$坐标的中位数为切分点，将数据集一分为二，大于$x_i^{(1)}$的中位数在右，小于在左。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。<br>&emsp;&emsp;<strong>将落在切分超平面的实例点保存在根节点。</strong><br>&emsp;&emsp;(2)重复切分操作，再将$x^{(2)}$作为切分的维度，并在之前已经一分为二的左边和右边分别找到$x^{(2)}$维度的中位数，接着分别切分到左右两边。<br>&emsp;&emsp;(3)一直重复切分操作,对深度为j的节点,选择$x^{(l)}$为切分的坐标轴，l=j(mod)k +1,以该结点的区域中所有实例的$x^{(l)}$坐标的中位数为切分点，将该结点对应的超平面矩形区域切分为两个子区域。<strong>将落在切分超平面的实例点保存在根节点。</strong><br>&emsp;&emsp;(4)直到两个子区域没有实例存在时停止。从而形成kd数的区域划分。</p><h1 id="搜索kd树（最近邻）"><a href="#搜索kd树（最近邻）" class="headerlink" title="搜索kd树（最近邻）"></a>搜索kd树（最近邻）</h1><p>&emsp;&emsp;下面介绍如何利用kd树进行最近邻搜索。利用kd树可以省去大部分数据点的搜索，从而减少搜索的计算量。<br>输入：（1）已经构造好的kd树（2）目标点x（想找到距离x最近的点）<br>输出： x的最近邻<br>&emsp;&emsp;（1）在kd树种找出包含目标点x的叶节点：从根节点出发，递归的向下访问kd树。若目标点x当前维（用哪个维度分的就用哪个维度）的坐标小于切分点的坐标，则移动到左子节点，否则移动到右子节点。直到找到子节点为叶节点为止。<br>&emsp;&emsp;（2）以次叶节点为‘当前最近点’<br>&emsp;&emsp;（3）<strong>递归</strong>（刚才一路下来的那些点都要进行接来下来的操作）地向上回退，在每个结点都进行以下操作：<br>&emsp;&emsp;&emsp;&emsp;a:如果该结点保存的实例点比当前最近点的距离（用选定的公式计算比如欧氏距离）目标点更近，则以该实例点为‘当前最近点’。<br>&emsp;&emsp;&emsp;&emsp;b:检查目前结点的另一子结点对应的区域是否以目标点为球心、以目标点与‘当前最近点’间的距离为半径的超球体相交。<br>&emsp;&emsp;&emsp;&emsp;若相交：可能在另一个子结点对应的区域内存在距离目标点更近的点，移动到另一个子结点，接着递归的向下搜索<br>&emsp;&emsp;&emsp;&emsp;如果不想交：向上回退。<br>&emsp;&emsp;（4）当退回到根节点时，搜索结束。最后的‘当前最近点’即为x的最近邻点。</p><p>&emsp;&emsp;kd数搜索的评论计算复杂度是O(logN),N是训练实例数.kd树更适用于训练实例数远大于空间维数时的k近邻搜索。</p><h1 id="搜索kd树-（K近邻）"><a href="#搜索kd树-（K近邻）" class="headerlink" title="搜索kd树*（K近邻）"></a>搜索kd树*（K近邻）</h1><p>输入：给定一个已经构建好的kd树，需要寻找的点P，需要寻找几个近邻K。<br>输出：L列表，L列表里有K个空位，每个空位装的是近邻点。</p><p>&emsp;&emsp;（1）根据切分的维度对比同维度下P的坐标值向下搜索。（也就是说，如果树的节点是照 $x_r=a$ 进行切分，并且 p 的 r 坐标小于 a，则向左枝进行搜索；反之则走右枝）。<br>&emsp;&emsp;（2）当到达叶子结点时，将其标记为访问过。如果L列表中不足k个点，则将当前结点的坐标加入到L列表。如果L列表不为空并且当前结点与P的距离小于L中所存放结点的最大距离，则用当前结点替换掉L中离P最远的结点。<br>&emsp;&emsp;（3）如果当前的结点不是整棵树最顶端的结点，执行a操作；反之，输出L列表。<br>&emsp;&emsp;&emsp;&emsp;a:向上爬一个结点。如果当前（向上爬过之后的）结点没有被访问过，将其标记为访问过，然后执行b和c操作；如果当前结点被访问过，再次执行a.<br>&emsp;&emsp;&emsp;&emsp;b:如果此时L列表中不足k个点，则将结点加入到L；如果L中已经满k个点，并且当前结点与P的距离小于 L列表中最远的距离的点，则用结点替换掉L中距离P最远的点。<br>&emsp;&emsp;&emsp;&emsp;c:计算p和当前结点切分线的距离（作垂线）。如果该距离大于等于L列表中距离最远的点并且L列表中已经有k个点，则在当前结点的另外一边（没访问过的那边）不会有更近的点，接着执行（3）；如果该距离小于L列表中距离最远的点或者L列表中不足k个点，则切分线另一边可能有更近的点，因此在当前结点的另外一边可能有更近的点，因此在当前结点的另外一边从（1）开始重新执行。</p><p>大概过成就是这样，下面有一个链接，链接里有距离寻找K近邻的例子。<br><a href="https://zhuanlan.zhihu.com/p/23966698" rel="external nofollow noopener noreferrer" target="_blank">搜索kd数k近邻搜索样例</a></p>]]></content>
    
    <summary type="html">
    
      记得第一次面试的时候，面试官问了我一道题，n个向量，怎么找到每个向量距离最近的向量，我想了好久，无奈只想到了两两计算这种垃圾方法，最近看统计学习方法的时候，看到了kd树，马上想起来原来可以用KD树来做。哎，现在写一篇记录一下。
    
    </summary>
    
      <category term="机器学习" scheme="https://pspxiaochen.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="kd树" scheme="https://pspxiaochen.club/tags/kd%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>该死的牛客网输入。</title>
    <link href="https://pspxiaochen.club/code_input/"/>
    <id>https://pspxiaochen.club/code_input/</id>
    <published>2018-06-25T13:27:00.000Z</published>
    <updated>2018-06-26T15:57:20.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python各种输入的方法。"><a href="#Python各种输入的方法。" class="headerlink" title="Python各种输入的方法。"></a>Python各种输入的方法。</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>&emsp;&emsp;<br>输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">7 15 9 5</span><br></pre></td></tr></table></figure></p><p>可以看到 第一行的输入的数是第二行输入数字的个数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">line = sys.stdin.readline()</span><br><span class="line">n = int(line) <span class="comment">#读进来的都是str类型，需要转换成int类型</span></span><br><span class="line">nums = [int(t) <span class="keyword">for</span> t <span class="keyword">in</span> sys.stdin.readline().split()]</span><br></pre></td></tr></table></figure></p><p>在这里我们主要看一下第4行代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums = [int(t) <span class="keyword">for</span> t <span class="keyword">in</span> sys.stdin.readline().split()]</span><br><span class="line"><span class="comment">#这一行的输出是[7,15,9,5]</span></span><br><span class="line"><span class="comment">#我们现在把他拆解一下，如果写成这样</span></span><br><span class="line">nums = sys.stdin.readline().split()</span><br><span class="line"><span class="comment">#现在这一行的输出变成了['7','15','9','5'],和之前的区别是现在list里每一个元素都是一个字符。</span></span><br><span class="line"><span class="comment">#如果再改成这样</span></span><br><span class="line">nums = sys.stdin.readline()</span><br><span class="line"><span class="comment">#现在的输出就变成了7 15 9 5，注意这是一个str，比如nums[3]，就会输出5，当然5也是一个字符。</span></span><br></pre></td></tr></table></figure></p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">3332</span><br><span class="line">3233</span><br><span class="line">3332</span><br><span class="line">2323</span><br></pre></td></tr></table></figure></p><p>可以看到第一行的第一个4控制接下来输入的行数，第一行的第二个4控制接下来每一行的输入的元素。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">m, n = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> sys.stdin.readline().split()]</span><br><span class="line">nums = [[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> sys.stdin.readline().strip()] <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line"><span class="comment">#重点看一下第3行的代码,相当于用了2层for循环</span></span><br><span class="line"><span class="comment">#外循环是运行m次int(x) for x in sys.stdin.readline().strip()，内循环是将每一行输入进来的str转换成int类型</span></span><br><span class="line"><span class="comment">#这一行将来的输出是一个二维数组</span></span><br><span class="line">[[3, 3, 3, 2], [3, 2, 3, 3],[3, 3, 3, 2],[2, 3, 2, 3]]</span><br></pre></td></tr></table></figure></p><p>目前还没看到别的不同的例子，如果今后碰到再补充。</p>]]></content>
    
    <summary type="html">
    
      之前一直刷的是leetcode，前几天做了XX服的笔试题，我的天，第一道编程题的输入都让我弄了好久，难受。这次我总结一下Python的输入，以备将来笔试用。
    
    </summary>
    
      <category term="code" scheme="https://pspxiaochen.club/categories/code/"/>
    
    
      <category term="笔试" scheme="https://pspxiaochen.club/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>K近邻法(KNN)之不再遗忘。</title>
    <link href="https://pspxiaochen.club/KNN/"/>
    <id>https://pspxiaochen.club/KNN/</id>
    <published>2018-06-22T13:27:00.000Z</published>
    <updated>2018-06-23T01:52:15.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K近邻算法的基本"><a href="#K近邻算法的基本" class="headerlink" title="K近邻算法的基本"></a>K近邻算法的基本</h1><p>&emsp;&emsp; k近邻法(k-nearest neighbor,KNN)是一种可以做分类也可以做回归的方法。是一种比较简单的方法，给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最近的K个实例，这K个实例的多数属于某个类，就把该输入实例分到这个类。</p><h2 id="基本过程："><a href="#基本过程：" class="headerlink" title="基本过程："></a>基本过程：</h2><p>&emsp;&emsp; 输入：训练数据集T和实例特征向量x.<br>&emsp;&emsp; 输出：实例x所属的类y.<br>&emsp;&emsp; 过程：（1）根据给定的距离度量，在训练集T中找到与x最近的k个点，涵盖着k个点的集合记作N。<br>&emsp;&emsp;&emsp;&emsp; &emsp;（2）在N中根据分类决策规则决定x的类别y,比如可以将N中类别最多的类别就定义为x的类别。</p><h2 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h2><p>&emsp;&emsp; 当k = 1的情形，称为最近邻算法。对于输入的实例点x，他的分类结果就是距离他最近的训练数据中的点。<br>&emsp;&emsp; 可以看出k近邻算法没有显式的学习过程。</p><h1 id="K近邻模型的三个基本要素"><a href="#K近邻模型的三个基本要素" class="headerlink" title="K近邻模型的三个基本要素"></a>K近邻模型的三个基本要素</h1><p><strong>三个基本要素分别是：距离度量、K值的选择、分类决策规则。</strong></p><h2 id="距离度量："><a href="#距离度量：" class="headerlink" title="距离度量："></a>距离度量：</h2><p>&emsp;&emsp; 特征空间中两个实例点的距离是两个实例点相似程度的反应。<br>&emsp;&emsp; 若有两个实例$x_i$和$x_j$，这两个实例的$L_p$距离被定义为：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$L_p(x_i,x_j)=(\sum_{i=1}^n|x_i^{(l)}-x_j^{(l)}|^p)^{\frac{1}{p}}$<br>&emsp;&emsp; p是&gt;=1的，当p=2时,我们称为欧式距离：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$L_p(x_i,x_j)=(\sum_{i=1}^n|x_i^{(l)}-x_j^{(l)}|^2)^{\frac{1}{2}}$<br>&emsp;&emsp;当p=1时，我们称为曼哈顿距离<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$L_p(x_i,x_j)=(\sum_{i=1}^n|x_i^{(l)}-x_j^{(l)}|)$<br>&emsp;&emsp;怎么通俗的理解曼哈顿距离和欧式距离呢<br>&emsp;&emsp;假如你现在想从宿舍去食堂吃饭，你有2种走法第一种就是两点之间线段最近，直接走一条直线，管他有没有障碍物全部都挡不住你，你是电，你是光，你是唯一的神话，这就叫欧氏距离。<br>&emsp;&emsp;还有一种走法就是你肯定得按照学校的规划道路上走，必须在路上，你不能穿墙，上天，入地。所以你可能会有好几种走法，但是都必须在路上走。这种就叫做曼哈顿距离。还有很多种距离，我只介绍这两种。<br>&emsp;&emsp;<strong>距离度量的选择可能会影响之后的结果。</strong></p><h2 id="K值的选择："><a href="#K值的选择：" class="headerlink" title="K值的选择："></a>K值的选择：</h2><p>K值的选择会对K近邻法的结果产生重大的影响。<br>&emsp;&emsp;先了解一下什么叫近似误差和估计误差<br>&emsp;&emsp;近似误差：可以理解为对现有训练集的训练误差。<br>&emsp;&emsp;估计误差：可以理解为对测试集的测试误差。</p><p>&emsp;&emsp;近似误差关注训练集，如果近似误差小了会出现过拟合的现象，对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。模型本身不是最接近最佳模型。<br>&emsp;&emsp;如果选择较小的k值，就相当于只有与输入实例较近（相似）的实例才会对预测结果起作用，‘学习’的近似误差会减小，估计误差会增大，如果邻近的实例点恰巧是噪声，预测就会出错。换句话说，K值的减小意味着整体模型变的复杂，容易发生过拟合。</p><p>&emsp;&emsp;如果选择比较大的k值，就相当于用较多的训练实例进行预测。有点是可以减少学习的估计误差，缺点是学习的近似误差会增大。这时与输入实例较远（不相似）的训练实例也会对预测起作用，使预测发生错误。K值的增大就意味着整体的模型变得简单。<br>&emsp;&emsp;如果K = N(样本总量) ，那么无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类。这时，模型过于简单，完全忽略训练实例中的大量有用信息，是不可取的。<br>&emsp;&emsp;<strong>在应用中，k值一般取一个比较小的数值。通常采用交叉验证法来选取最优的k值。</strong></p><h2 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h2><p>&emsp;&emsp;K近邻法中的分类决策规则往往是多数表决，即由输入实例的k个邻近的训练实例中的多数类决定输入实例的类。</p><h1 id="KNN的优缺点"><a href="#KNN的优缺点" class="headerlink" title="KNN的优缺点"></a>KNN的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.简单，易于理解，易于实现，无需参数估计，无需训练，既可以用来做分类也可以用来做回归；<br>2.可用于数值型数据和离散型数据；<br>3.训练时间复杂度为O(n)；无数据输入假定；<br>4.对异常值不敏感,kNN不会受到差别特别大的样本中的特征元素的影响(对异常值不敏感)。因为采用了归一化技术。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>1.计算复杂性高；空间复杂性高；<br>2.可解释性差，无法告诉你哪个变量更重要，无法给出决策树那样的规则；<br>3.K值的选择：最大的缺点是当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。可以采用权值的方法（和该样本距离小的邻居权值大）来改进;<br>4.最大的缺点是无法给出数据的内在含义。<br>5.消极学习方法、懒惰算法。</p><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><ol><li>计算已知类别数据集中的点与当前点之间的距离（值域越大的变量常常会在距离计算中占据主导作用，需要进行归一化或者标准化处理）；</li><li>按照距离递增次序排序； </li><li>选择与当前距离最小的k个点； </li><li>确定前k个点所在类别的出现概率 ；</li><li>返回前k个点出现频率最高的类别作为当前点的预测分类。</li></ol>]]></content>
    
    <summary type="html">
    
      今天开始整理！
    
    </summary>
    
      <category term="机器学习" scheme="https://pspxiaochen.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="KNN" scheme="https://pspxiaochen.club/tags/KNN/"/>
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯之了断心结。</title>
    <link href="https://pspxiaochen.club/bys/"/>
    <id>https://pspxiaochen.club/bys/</id>
    <published>2018-05-30T13:27:00.000Z</published>
    <updated>2018-06-25T03:37:41.161Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; 为什么说贝叶斯一直是我的心结呢。这说来就话长了，当初考研时，想都没想就选择了相对简单的专硕（现在看来其实也并不简单），而我们学习的专硕是不考概率论的，所以基本上我的概率论体系还停留在高中阶段。那你又要问了，难道一个计算机科班出身的，本科就没学过概率论么，说到这里我就想起来我的概率论老师上课操着一口湖南口音，声音很小，150个人的大教室，而我在最后一排和舍友疯狂的搓着3DS，咳咳。说远了。今天我一定用最通俗理解的方法把朴素贝叶斯里的每一个知识点都梳理一遍，算是对自己有一个交代。</p><h1 id="如果没什么概率论基础的话先推荐一篇文章"><a href="#如果没什么概率论基础的话先推荐一篇文章" class="headerlink" title="如果没什么概率论基础的话先推荐一篇文章"></a>如果没什么概率论基础的话先推荐一篇文章</h1><p><a href="https://www.jianshu.com/p/b570b1ba92bb" rel="external nofollow noopener noreferrer" target="_blank">应该如何理解概率分布函数和概率密度函数？</a></p><h1 id="生成式模型和判别式模型。"><a href="#生成式模型和判别式模型。" class="headerlink" title="生成式模型和判别式模型。"></a>生成式模型和判别式模型。</h1><p>&emsp;&emsp;在讲贝叶斯之前我觉得我有理由先说一下什么是生成式模型而什么是判别式模型。在《统计学习方法》书中明确写道：<strong>监督学习方法又可以分为生成方法和判别方法，所学到的模型分别称为生成模型和判别模型。</strong></p><h2 id="生成式模型："><a href="#生成式模型：" class="headerlink" title="生成式模型："></a>生成式模型：</h2><p>&emsp;&emsp;生成方法由数据学习联合概率分布P(X,Y),然后求出条件概率分布P（Y|X）作为预测模型，即生成模型 P（Y|X）= P(X,Y) / P(X),这样的方法之所以称为生成方法，是因为模型表示了给定输入X产生输出Y的生成关系。我们今天的主角朴素贝叶斯就是生成模型，常见的还有隐马尔科夫模型。<br>&emsp;&emsp;生成方法的特点：生成方法可以还原出联合概率分布P（X,Y），而判别方法则不能。生成方法的学习收敛速度更快，即当样本容量增加的时候，学到的模型可以更快的收敛于真实模型。</p><h2 id="判别式模型："><a href="#判别式模型：" class="headerlink" title="判别式模型："></a>判别式模型：</h2><p>&emsp;&emsp;判别方法由数据直接学习决策函数f(X)或者条件概率分布P（Y|X）作为预测的模型。判别方法关系的是对给定的输入X，应该预测什么样的输入出Y。<br>&emsp;&emsp;判别方法的特点：判别方法直接学习的是条件概率P（Y|X）或者决策函数F（X），直接面对预测，往往学习的准确率更高。由于直接学习P（Y|X）或者F（X），可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;两种模型都是利用条件概率判别，只不过生成模型通过求解联合分布得到条件概率，而判别模型直接计算条件概率，如果你不知道什么是联合概率分布，我一会会解释，别怕。</p><h1 id="现在开始我们的主菜（朴素贝叶斯）"><a href="#现在开始我们的主菜（朴素贝叶斯）" class="headerlink" title="现在开始我们的主菜（朴素贝叶斯）"></a>现在开始我们的主菜（朴素贝叶斯）</h1><p>&emsp;&emsp;首先先声明一点，朴素贝叶斯与贝叶斯估计是不同的概念。那为什么叫朴素呢。是因为他假设特征条件都相互独立（不过一般都是不可能的）。所以说朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。<br>&emsp;&emsp;X是定义在输入空间上的随机向量，Y是定义在输出空间上的随机变量。P（X,Y）是X和Y的联合概率分布。训练数据集由P（X,Y）独立同分布产生。<br>&emsp;&emsp;朴素贝叶斯通过训练数据集学习联合概率分布P（X,Y），那我们现在说说什么是联合概率分布。</p><h2 id="联合概率分布"><a href="#联合概率分布" class="headerlink" title="联合概率分布"></a>联合概率分布</h2><p>&emsp;&emsp;联合概率分布简称联合分布，是两个及以上随机变量组成的随机向量的概率分布。根据随机变量的不同，联合概率分布的表示形式也不同。对于离散型随机变量，联合概率分布可以以列表的形式表示，也可以以函数的形式表示；对于连续型随机变量，联合概率分布通过一非负函数的积分表示。打靶时命中的坐标（x，y）的概率分布就是联合概率分布（涉及两个随机变量），其他同样类比。</p><h3 id="连续型联合概率分布"><a href="#连续型联合概率分布" class="headerlink" title="连续型联合概率分布"></a>连续型联合概率分布</h3><p>&emsp;&emsp;对于二维连续随机向量，设X,Y为连续性随机变量，其联合概率分布或连续性随机变量（X,Y）的概率分布F（x,y）通过一非负函数f(x,y) &gt;= 0的积分表示，称函数f(x,y)为联合概率密度函数。两者关系如下：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://wx4.sinaimg.cn/mw690/72fdc620ly1frt7rhf6r7j2085049t8n.jpg" alt="此处输入图片的描述"></p><p>在接上面，我们想要通过训练数据集学习联合概率分布P（X,Y）= P(XY），而我们知道条件概率公式：       <strong>P(AB)=P(A|B)P(B)=P(B|A)P(A)</strong> ，所以我们只要知道先验概率分布以及条件概率分布。就可以得到联合概率分布。<br>&emsp;&emsp;朴素贝叶斯对条件概率分布做了条件独立性的假设。这个是较强的假设。具体的，条件独立性假设是：<br>&emsp;&emsp;&emsp;&emsp;<img src="http://wx2.sinaimg.cn/mw690/72fdc620ly1frtexqhkpnj20od02x401.jpg" alt="此处输入图片的描述"><strong>（1）</strong><br>这个公式可以这么理解：当事件A1，A2，A3相互独立时，有P(A1,A2,A3）= P（A1)P(A2)P(A3)<br>p(A1,A2,A3|B) = P(A1|B)<em>P(A2|B)</em>P(A3|B)</p><p>&emsp;&emsp;朴素贝叶斯法分类时，对给定的输入x,通过学习到的模型计算后验概率分布P=（Y=c_k|X=x)，将后验概率最大的类作为x的类输出，后验概率计算根据贝叶斯定理进行,现在开始手推公式：<br>由条件概率公式得到：$P(Y=c_k|X=x)=\frac{p(X=x,Y=c_k)}{P(x)} = \frac{P(X=x|Y=c_k)P(Y=c_k)}{P(X=x)}$    <strong>（2）</strong></p><p>再由全概率公式得到：$P(X=x) = \sum_{k} P(Y=c_k)P(X=x|Y=c_k)$    <strong>（3）</strong></p><p>将（3）带入（2）得到：$P(Y=c_k|X=x)=\frac{p(X=x,Y=c_k)P(Y=c_k)}{\sum_{k} P(Y=c_k)P(X=x|Y=c_k)}$    <strong>（4）</strong></p><p>再将（1）带入（4）得到：$P(Y=c_k|X=x)=\frac{P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|P(Y=c_k)}{\sum_{k}P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|P(Y=c_k)}，k=1,2,3,K。$ </p><p>到此朴素贝叶斯分类器可以表示为：$y=f(x)=\arg\min_{c_k}\frac{P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|P(Y=c_k)}{\sum_{k}P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|P(Y=c_k)}$</p><p>由于分母就是$P(X=x)$ 所以对于所有c_k来说都是相等的，所以可以把分母省略掉。所以最后的公式为：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$y=f(x)=\arg\min_{c_k}{P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|P(Y=c_k)}$</p><h1 id="后验概率最大化的含义"><a href="#后验概率最大化的含义" class="headerlink" title="后验概率最大化的含义"></a>后验概率最大化的含义</h1><p>朴素贝叶斯将实例分到后验概率最大的类中，也就是希望损失函数尽量的小，损失函数越小，模型越好，只需所有的样本点都求一次损失函数然后进行累加就是经验风险，我们希望让经验风险也尽可能的越小越好，经验风险是对训练集中的所有样本点损失函数的平均最小化。经验风险越小说明模型f(X)对训练集的拟合程度越好，但是对于未知的样本效果怎么样呢？我们知道未知的样本数据（X,Y）的数量是不容易确定的，所以就没有办法用所有样本损失函数的平均值的最小化这个方法，那么怎么来衡量这个模型对所有的样本（包含未知的样本和已知的训练样本）预测能力呢？熟悉概率论的很容易就想到了用期望。<br>这下我们又得再来说说数学期望了，数学期望想必都比较数学，我只说一下离散型和连续型求法的区别。</p><h2 id="离散型："><a href="#离散型：" class="headerlink" title="离散型："></a>离散型：</h2><p>$E(X)=\sum_{i}x_ip_i$</p><h2 id="连续型："><a href="#连续型：" class="headerlink" title="连续型："></a>连续型：</h2><p>$E(X)=\int_{-\infty}^{+\infty} {xf(x)} \,{\rm d}x$&emsp;&emsp;&emsp;&emsp;&emsp;$f(x)$为概率密度函数。</p><p>假设我们的损失函数是0-1损失函数：<br>&emsp;&emsp;&emsp;&emsp;<img src="http://wx3.sinaimg.cn/mw690/72fdc620ly1fruanmcwi7j20h802zt8o.jpg" alt="此处输入图片的描述"><br>设X和Y服从联合分布P(X,Y).那么期望风险就可以表示为：$R_{exp}(f) = E[L(Y,f(x))]$<br>接着推公式得到：<br>$R_{exp}(f) = E[L(Y,f(x))]$<br><img src="http://wx4.sinaimg.cn/mw690/72fdc620ly1fruavgwi8ij209h04x3yr.jpg" alt="此处输入图片的描述"><br>可以看出最后变成了条件期望。<br>&emsp;&emsp;这就是期望风险，期望风险表示的是全局的概念，表示的是决策函数对所有的样本<x,y>预测能力的大小，而经验风险则是局部的概念，仅仅表示决策函数对训练数据集里样本的预测能力。理想的模型（决策）函数应该是让所有的样本的损失函数最小的（也即期望风险最小化），但是期望风险函数往往是不可得到的，即上式中，X与Y的联合分布函数不容易得到。现在我们已经清楚了期望风险是全局的，理想情况下应该是让期望风险最小化，但是呢，期望风险函数又不是那么容易得到的。怎么办呢？那就用局部最优的代替全局最优这个思想吧。这就是经验风险最小化的理论基础。<br>&emsp;&emsp;为了使条件期望最小化，只需要对X=x每一个都极小化：<br><img src="http://wx2.sinaimg.cn/mw690/72fdc620ly1frubc6ht1vj20ui0ba763.jpg" alt="此处输入图片的描述"></x,y></p><p>根据期望风险最小化准则就得到了后验概率最大化准则。</p><p>总的来说 朴素贝叶斯就是把朴素的思想（条件独立性）带入到贝叶斯公式之中，来得到朴素贝叶斯分类器。中间需要计算先验概率和条件概率，然后通过极大似然估计可以估计这些参数。</p><p>最后在推荐2篇文章，里面写的十分详细。<br><a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" rel="external nofollow noopener noreferrer" target="_blank">数学之美番外篇：平凡而又神奇的贝叶斯方法</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html" rel="external nofollow noopener noreferrer" target="_blank">贝叶斯推断及其互联网应用（一）：定理简介</a></p>]]></content>
    
    <summary type="html">
    
      今天就要和围绕我两年之久的心结做个了断！！！！
    
    </summary>
    
      <category term="机器学习" scheme="https://pspxiaochen.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="贝叶斯" scheme="https://pspxiaochen.club/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>我自己理解的梯度下降的原理</title>
    <link href="https://pspxiaochen.club/2018-05-24-GD/"/>
    <id>https://pspxiaochen.club/2018-05-24-GD/</id>
    <published>2018-05-23T13:27:00.000Z</published>
    <updated>2018-07-05T09:38:04.650Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近不太顺啊，各种碰壁，看来学习确实容不得半点虚假，会就是会，不会就是不会。现在决定再认认真真复习一遍机器学习和数据结构，再来巩固一下自己的知识体系，只希望这次可以别忘的太快。</p><h1 id="我们为什么要使用梯度下降。"><a href="#我们为什么要使用梯度下降。" class="headerlink" title="我们为什么要使用梯度下降。"></a>我们为什么要使用梯度下降。</h1><p>&emsp;&emsp;因为机器学习总的来说是一个优化问题。我们有一个想要优化的函数，比如说损失函数，我们总是希望可以让损失函数变得越来越小。那怎么才能使损失函数变得原来越小呢？损失函数中有一些未知的参数，我们只要不停更新这个参数，就可以让损失函数越来越小。直到损失函数等于0或者不再发生变化为止。所以说梯度下降是用来更新一些未知参数的，而这些参数会使损失函数越来越小。</p><h1 id="梯度下降是怎么来的呢？"><a href="#梯度下降是怎么来的呢？" class="headerlink" title="梯度下降是怎么来的呢？"></a>梯度下降是怎么来的呢？</h1><p>&emsp;&emsp;首先我们来看一元函数的泰勒展开，以便于更好的理解多元函数的泰勒展开。如果一个一元函数n阶可导，它的泰勒展开公式为：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://wx1.sinaimg.cn/mw690/72fdc620ly1frm73g6o3yj20x602uaac.jpg" alt="泰勒公式"><br>&emsp;&emsp;如果在某一点处的导数值大于0（+），则函数在此处是增函数，加大x的值函数会增加，减小x的值函数会减小。相反的，如果在某一点处导数值小于0（-），则函数是减函数，增加x的值函数值会减小（+），减小x的值函数会增加。因此我们可以得出一个结论：<strong>如果x的变化很小，并且变化值与导数值反号，则函数值下降。</strong>对于一元函数，x的变化只有两个方向，要么朝左，要么朝右。</p><p>&emsp;&emsp;下面我们把这一结论推广到多元函数的情况。多元函数f(x)在x点处的泰勒展开为：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://wx3.sinaimg.cn/mw690/72fdc620ly1frm7e3gn0zj20mk028t8s.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;这里我们忽略了二次以及更高的项。其中一次项是梯度向量▽f(x)与自变量的增量△X的內积，这等价于一元函数的一次项f’(X0)(X-X0)。这样，函数的增量与自变量的增量△X、函数梯度的关系可以表示为：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://wx4.sinaimg.cn/mw690/72fdc620ly1frm7r65pc0j20mu02iq31.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;如果△X足够小，在X的某一领域内，则我们可以忽略二次及以上的项，有：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://wx1.sinaimg.cn/mw690/72fdc620ly1frm7taxkn3j20mi02ejrf.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;这里的情况比较复杂，△X是一个向量，有无穷多种方向，该往哪个方向走呢？如果能保证上面约等式的右边恒小于0，则有：<strong>f(x+△x) &lt; f(x)</strong>，即函数值递减，这就是下山的正确方向。如果这句话还不能理解，我们可以再换一种方式理解。假如x是我们想要更新的参数,f(x)是我们刚开始需要优化的损失函数,我们很希望可以让f(x)越来越小，那怎么才能够让其越来越小呢。就如我一开始说的那样我们要不停的更新里面的参数,而x就是我们要更新的那个参数。用数学表达式就是<strong>min(f(x+△x)）</strong>，如果<strong>f(x+△x) &lt; f(x)</strong>恒成立，那就是说，我们的优化函数一直再减小，那么可以理解为一定会找到一个完美的结果，是不是想想就有点小开心呢，但是往往不会有那么好的事情的，就和人生一样。<br>&emsp;&emsp;再接上面，那我们怎么样才能保证约等式的右边恒小于0呢，因为有：<br>&emsp;&emsp;&emsp;&emsp;<img src="http://wx3.sinaimg.cn/mw690/72fdc620ly1frm8akufs2j20mw02adfv.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;在这里，||·||表示向量的模，θ是向量▽f(x)和△x的夹角。因为向量的模一定大于等于0，所以说如果cosθ &lt;= 0,则能保证约等式的右边恒小于0。也就是选择合适的增量△x，就能保证函数数值下降，要达到这种效果，只要保证梯度和△x的夹角的余弦值小于等于0就行。由于cosθ &gt;= -1，当θ = π时，cosθ有极小值-1，此时梯度和△x反向，夹角为180度，因此当向量△X的模大小一定时，当：△X = - ▽f(x),也就是在梯度相反的方向函数值下降最快。此时有cosθ = -1。<strong>重点来了：那我们为什么要让△X = - ▽f(x)呢，让它等于别的不可以吗？这一块我考虑了好半天，最后我只能这么解释一下。如果我们想让约等式的右边小于等于0恒成立，怎么办！！怎么样才能保证最靠谱呢？那我不如让△X = - ▽f(x)算了，一个平方的值带负号是一定小于等于0的。这也太靠谱了吧！！我觉得这么取得意义就在这里，仅此而已。</strong><br>&emsp;&emsp;也就是说只要梯度不为0，往梯度的反方向走函数值一定是下降的。直接用△X = - ▽f(x)可能会有问题，因为x+△x可能会超出x的领域范围之外，此时是不能忽略泰勒展开中的二次及以上的项的，因此步伐不能太大，一般设△x = -α▽f(x)。其中α为一个接近于0的正数，称为步长，由人工设定。<br>&emsp;&emsp;从初始点X_0开始，使用此迭代公式：X_k+1 = X_k - α▽f(x).<br>&emsp;&emsp;只要没有到达梯度为0的点，则函数值会沿着序列X_k递减，最终会收敛到梯度为0的点，这就是梯度下降法。迭代终止的条件是函数的梯度值为0（实际是接近于0），此时认为已经达到了极值点。注意我们找到的是梯度为0的点，这不一定就是极值点。梯度下降法只需要计算函数在某些点处的梯度，实现简单，计算量小。<br>&emsp;&emsp;再写一套比较直观的公式推导，看完有点原来如此，so easy的感觉~~<br>&emsp;&emsp;$f(x_{k+1}) = f(x_k + x_{k+1} - x_k) = f(x_k) + ▽f(x_k)(x_{k+1} - x_k)$<br>&emsp;&emsp;$▽f(x_k)$即为函数f在$x_k$处的梯度。<br>&emsp;&emsp;为了使$f(x_{k+1}) &lt; f(x_k)$,则需要$▽f(x_k)(x_{k+1} - x_k)&lt;0$<br>&emsp;&emsp;则只需要使$x_{k+1}=x_k - \gamma▽f(x_k)$即可。<br>&emsp;&emsp;上式便是梯度下降的迭代公式，其中$\gamma$为学习速率。这样看是不是很清楚了呢。。。</p>]]></content>
    
    <summary type="html">
    
      思考了一晚上总算是稍微理解一些了！！！开心！
    
    </summary>
    
      <category term="机器学习" scheme="https://pspxiaochen.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="梯度下降" scheme="https://pspxiaochen.club/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>从拉格朗日乘子法再到KKT条件的理解</title>
    <link href="https://pspxiaochen.club/lagrange%20and%20kkt/"/>
    <id>https://pspxiaochen.club/lagrange and kkt/</id>
    <published>2017-12-26T13:27:00.000Z</published>
    <updated>2017-12-26T13:31:10.714Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;西瓜书看了有一阵子了，终于看到了SVM，遥想研一看SVM的时候。。我操 这是什么。。这又是什么。。论高中数学的重要性的，出来混都是要还的。只好一点一点补齐SVM中用到的各种知识点。今天先扯一扯自己对拉格朗日乘子法和KKT条件的理解，希望这篇文章写完之后，能让我对这2个臭逼玩意能有更好的理解，那么现在开始。</p><h1 id="我们为什么在SVM中要用到拉格朗日和KKT条件！！！"><a href="#我们为什么在SVM中要用到拉格朗日和KKT条件！！！" class="headerlink" title="我们为什么在SVM中要用到拉格朗日和KKT条件！！！"></a>我们为什么在SVM中要用到拉格朗日和KKT条件！！！</h1><p>&emsp;&emsp;因为在SVM中我们要计算一个有约束条件的极值问题，而拉格朗日乘子法和KKT条件是非常重要的两个求取方法。<br><br><br>&emsp;&emsp;对于等式约束的优化问题（就是限制的那个式子是个等式 s.t h(x) = 0 类似这种），可以应用拉格朗日乘子法去求取最优值。<br>&emsp;&emsp;如果含有不等式约束，可以应用KKT条件去求取最优值。<br>&emsp;&emsp;这两种方法求得的结果只是必要条件，只有当是凸函数（二次导数大于0为凸）的情况下，才能保证是充分必要条件。而KKT条件是拉格朗日乘子法的泛化。<br>&emsp;&emsp;下面我就针对这两个玩意，谈一谈我的理解。</p><h1 id="拉格朗日乘子法！！！"><a href="#拉格朗日乘子法！！！" class="headerlink" title="拉格朗日乘子法！！！"></a>拉格朗日乘子法！！！</h1><p>&emsp;&emsp;拉格朗日乘子法在考研的数学二中就用到过，当时只知道要那么用，那么用就能解决条件极值的问题，但是真心不知道为什么，这次先把为什么可以用拉格朗日说一下。<br>&emsp;&emsp;想象一下，目标函数f(x,y)是一座山的高度，约束g(x,y)=C是镶嵌在山上的一条曲线如下图。（渣画技看看就好了）<br><img src="http://wx4.sinaimg.cn/mw690/72fdc620ly1fmu7qn45b7j20k00akt8o.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;你为了找到曲线上的最低点，就从最低的等高线（0那条）开始网上数。数到第三条，等高线终于和曲线有交点了（如上图所示）。因为比这条等高线低的地方都不在约束范围内，所以这肯定是这条约束曲线的最低点了。<br><br><br>&emsp;&emsp;而且约束曲线在这里不可能和等高线相交，一定是相切。因为如果是相交的话，如下图所示，那么曲线一定会有一部分在B区域，但是B区域比等高线低，这是不可能的。假设g(x)与等高线相交，交点就是同时满足等式约束条件和目标函数的可行域的值，但肯定不是最优值，因为相交意味着肯定还存在其它的等高线在该条等高线的内部或者外部，使得新的等高线与目标函数的交点的值更大或者更小，只有到等高线与目标函数的曲线相切的时候，可能取得最优值。<br><img src="http://wx3.sinaimg.cn/mw690/72fdc620ly1fmu88xe79yj209004yjr6.jpg" alt="此处输入图片的描述"><br><img src="http://wx4.sinaimg.cn/mw690/72fdc620ly1fmu88uoupyj208c060747.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;两条曲线相切，意味着他们在这点的法线平行，也就是法向量只差一个任意的常数乘子（取为-λ）：<br>&emsp;&emsp;<strong>∇f（x, y) = -λ(∇g(x,y)-C)</strong> 把这个式子的右边移动到左边，就得到<strong>∇（f(x,y)+λ(g(x,y)-C)=0</strong><br>&emsp;&emsp; 在看看这个式子，你又能想起来什么呢？高中数学。。。这个就是<strong>f(x,y)+λ(g(x,y)-C)</strong>没有约束情况下极值点的充分条件吧。。（令其导数等于0，求极值点。。。高中用的就是这个套路。。哎）所以证明了拉格朗日乘子法确实可以解决这类问题，拉格朗日确实牛逼。。高中数学也应该好好学 哎。难受啊。<br>&emsp;&emsp;那拉格朗日乘子法到底是怎么用的呢？简单的再说一下就是 <strong>把等式约束hi(x)用一个系数与f(x)写为一个式子，称为拉格朗日函数，而系数称为拉格朗日乘子。通过拉格朗日函数对各个变量求导，令其为零，可以求得候选值集合，然后验证求得最优值。</strong><br><br></p><h1 id="KKT条件！！！！！"><a href="#KKT条件！！！！！" class="headerlink" title="KKT条件！！！！！"></a>KKT条件！！！！！</h1><p>&emsp;&emsp;我先给出KKT条件：<br>&emsp;&emsp;对于具有等式和不等式约束的一般优化问题：<br>&emsp;&emsp;<img src="http://wx4.sinaimg.cn/mw690/72fdc620ly1fmu94wrl0aj207x02k746.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;KKT条件给出了判断<strong>X*</strong>是否是最优解的必要条件：<br>&emsp;&emsp;<img src="http://wx2.sinaimg.cn/mw690/72fdc620ly1fmu94z9hz2j20cw04nwem.jpg" alt="此处输入图片的描述"></p><h2 id="不等式约束优化问题"><a href="#不等式约束优化问题" class="headerlink" title="不等式约束优化问题"></a>不等式约束优化问题</h2><p>&emsp;&emsp;我们先给出其主要思想：转化的思想——将不等式约束条件变成等式约束条件.具体做法：<strong>引入松弛变量</strong>.松弛变量也是优化变量，也需要<strong>一视同仁求偏导.</strong><br><img src="http://wx3.sinaimg.cn/mw690/72fdc620ly1fmu9qs81wdj20k00a8mxa.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;具体来说，我们先看一个一元函数的例子：<br>&emsp;&emsp;&emsp;&emsp;<strong>min f(x)</strong><br>&emsp;&emsp;<strong>s.t. g1(x) = a - x ≤ 0</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>g2(x) = x - b ≤ 0</strong><br>&emsp;&emsp;（注：优化问题中，我们必须求得一个确定的值，因此不妨令所有的不等式均取到等号，即≤的情况.）<br>&emsp;&emsp;对于约束<strong>g1和g2</strong>,我们分别引入两个松弛变量<strong>a₁²和b₁²</strong>,得到<strong>h1(x,a₁) = g1 + a₁² = 0和h2(x,b₁) = g2 + b₁² = 0</strong>,这里直接加上平方项<strong>a₁²和b₁²</strong>而非<strong>a₁和b₁</strong>,是因为<strong>g1和g2</strong>这两个不等式的左边必须加上一个正数（或者0）才能使不等式变成等式。若只加上<strong>a₁和b₁</strong>,又会引入新的约束a₁≥0,b₁≥0.这岂不是很爆炸！！！<br><img src="http://wx4.sinaimg.cn/mw690/72fdc620ly1fmua4u75oxj20j4039t9u.jpg" alt="此处输入图片的描述"><br>&emsp;&emsp;由此我们将不等式约束转化为了等式约束，并得到了拉格朗日函数<br>L（x,a₁,b₁,u₁,u₂) = f(x) + u₁(a - x + a₁²) + u₂(x - b + b₁²)<br>&emsp;&emsp;我们再按照等式约束优化问题对齐求解，联立方程组：<br><img src="http://wx1.sinaimg.cn/mw690/72fdc620ly1fmubpsfd0oj20d9072dhm.jpg" alt="此处输入图片的描述"><br>（注：这里的u₁ ≥ 0,u₂ ≥ 0先承认，等会再解释，实际上对于不等式约束前的乘子，我们要求其大于等于0）<br>得出方程组后，便开始手动解，先看第3行的两个式子 <strong>u₁a₁ = 0 和 u₂b₁ = 0</strong>比较简单，我们就从他们入手。<br>对于<strong>u₁a₁ = 0</strong>,我们有两种情况:<br>情形1: <strong>u₁ = 0,a₁ ≠ 0:</strong><br>此时由于乘子<strong>u₁ = 0</strong>,<strong>因此g1与其相乘为0，可以理解为约束g1不起作用，且有g1(x) = a - x &lt; 0 (因为a₁ ≠ 0 , 所以他的平方一定是大于0的）</strong><br><br><br>情形2：<strong>u₁ ≥ 0 , a₁ = 0</strong><br><strong>此时，g1(x) = a - x = 0 且 u1 &gt; 0 (因为a₁ = 0 为了 a - x + a₁² = 0 ， 所以 a - x必须等于0），可以理解为约束g1起作用了，且有g1(x) = 0</strong></p><p><strong>合并两种情况的：u1g1 = 0 且在约束起作用时,u₁ &gt; 0,g1(x) = 0;约束不起作用时u1 = 0,g1(x) &lt; 0</strong><br><strong>同样的，分析u₂b₁ = 0,可得出约束g2起作用和不起作用的情形，并分析得到u₂g₂ = 0</strong><br>由此，方程组（极值必要条件）转化为：<br><img src="http://wx3.sinaimg.cn/mw690/72fdc620ly1fmubpstwbhj207l033748.jpg" alt="此处输入图片的描述"><br>这是一元一次的情形，类似的，对于多远多次不等式约束问题<br><strong>min f(x)<br>s.t.g_j(x) ≤ 0 ( j = 1,2,````,m)</strong><br>我们有<br><img src="http://wx3.sinaimg.cn/mw690/72fdc620ly1fmubptawonj20bh03j3yk.jpg" alt="此处输入图片的描述"><br>上式便称为不等式约束优化问题的KKT（Karush-Kuhn-Tucker）条件u_j称为KKT乘子，且约束起作用时u_j＞0,g_j(x) = 0;约束不起作用时u_j = 0,g_j(x) &lt; 0.</p><h1 id="总结：同时包含等式和不等式约束的一般优化问题"><a href="#总结：同时包含等式和不等式约束的一般优化问题" class="headerlink" title="总结：同时包含等式和不等式约束的一般优化问题"></a>总结：同时包含等式和不等式约束的一般优化问题</h1><p><img src="http://wx2.sinaimg.cn/mw690/72fdc620ly1fmuhrzcvsbj20dw083weu.jpg" alt="此处输入图片的描述"><br><strong>注意，对于等式约束的Lagrange乘子，并没有非负的要求！以后求其极值点，不必再引入松弛变量，直接使用KKT条件判断！</strong></p>]]></content>
    
    <summary type="html">
    
      这次想填一个超级大的坑！！！！！
    
    </summary>
    
      <category term="机器学习" scheme="https://pspxiaochen.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SVM" scheme="https://pspxiaochen.club/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>偏差与方差的总结</title>
    <link href="https://pspxiaochen.club/2017-12-12-bias-var/"/>
    <id>https://pspxiaochen.club/2017-12-12-bias-var/</id>
    <published>2017-12-12T13:27:00.000Z</published>
    <updated>2017-12-26T03:11:52.843Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天开始重新仔细学习西瓜书（机器学习），今天看完了第一章，第一章基本都是一些概念的东西，公式也比较少，希望可以坚持把这本书看完。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>&emsp;&emsp;根据各种公式推导得知，泛化误差 = 偏差 + 方差 +噪声<br>&emsp;&emsp;而偏差（bias）度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力。方差(Variance)度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。<br><img src="http://wx4.sinaimg.cn/mw690/72fdc620ly1fmtzttg0l6j20k00iydgl.jpg" alt="此处输入图片的描述"></p><h1 id="偏差与方差的关系"><a href="#偏差与方差的关系" class="headerlink" title="偏差与方差的关系"></a>偏差与方差的关系</h1><p>&emsp;&emsp;偏差与方差是有冲突的。给定学习任务，假定我们能控制学习算法的训练程度，则在训练不足时，模型的拟合能力不够强，训练数据的扰动不足以使模型产生显著变化，此时偏差主导了泛化错误率；随着训练程度的加深，模型的拟合能力逐渐增强，训练数据发生的扰动渐渐能被模型学习到，方差逐渐主导了泛化错误率；在训练程度充足后，模型的拟合能力已经非常强，训练数据发生的轻微扰动都会导致模型发生显著变化，若训练数据自身的，非全局性的特性被模型学习到了，则将发生过拟合。<br><img src="http://wx1.sinaimg.cn/mw690/72fdc620ly1fmtztpugfsj20fe0blq9x.jpg" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      自己对偏差或者方差的一些理解。
    
    </summary>
    
      <category term="机器学习" scheme="https://pspxiaochen.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="偏差" scheme="https://pspxiaochen.club/tags/%E5%81%8F%E5%B7%AE/"/>
    
      <category term="方差" scheme="https://pspxiaochen.club/tags/%E6%96%B9%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>Sum of Two Integers（使用位运算实现）</title>
    <link href="https://pspxiaochen.club/2017-12-07-add/"/>
    <id>https://pspxiaochen.club/2017-12-07-add/</id>
    <published>2017-12-07T08:27:00.000Z</published>
    <updated>2017-12-07T08:37:43.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;两个数的加法分为两步，对应位相加和进位。<br><br><br>&emsp;&emsp;举个简单的例子：997+24<br><img src="http://images2015.cnblogs.com/blog/920491/201607/920491-20160712110859998-340357180.png" alt="此处输入图片的描述"></p><p>  &emsp;&emsp;我们平时计算时是将对应位相加和进位同时计算，其实可以保留下进位，只计算对应位相加，保留进位的位置（值）。接下来，将进位向左移动一位，将上一步的结果与移位后的进位值进行对应位相加，直到没有进位结束。<br>  &emsp;&emsp;对于二进制数的而言，对应位相加就可以使用异或（xor）操作，计算进位就可以使用与（and）操作，在下一步进行对应位相加前，对进位数使用移位操作（&lt;&lt;）。<br>  <br><br>&emsp;&emsp;这样就非常好理解下面的实现代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int getSum(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        int c = a ^ b;</span><br><span class="line">        b = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">        a = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> a;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，再给一个详细的运行过程示意，计算523+1125.（另外，如果是有负数的话，算法也是可行的，可以去看一下补码的相关内容）<br><img src="http://images2015.cnblogs.com/blog/920491/201607/920491-20160712112232779-1674865256.png" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
    
    </summary>
    
      <category term="刷题" scheme="https://pspxiaochen.club/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="位运算" scheme="https://pspxiaochen.club/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="异或" scheme="https://pspxiaochen.club/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>峰度（Kurtosis）和偏度（Skewness）</title>
    <link href="https://pspxiaochen.club/2017-11-28-Kurtosis/"/>
    <id>https://pspxiaochen.club/2017-11-28-Kurtosis/</id>
    <published>2017-11-28T11:12:00.000Z</published>
    <updated>2017-11-28T13:24:18.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="峰度（Kurtosis）"><a href="#峰度（Kurtosis）" class="headerlink" title="峰度（Kurtosis）"></a>峰度（Kurtosis）</h1><p>&emsp;&emsp;峰度是描述总体中所有取值分布形态陡缓程度的统计量。这个统计量需要与正态分布相比较，峰度为0表示该总体数据分布与正态分布的陡缓程度相同；峰度大于0表示该总体数据分布与正态分布相比较为陡峭，为尖顶峰；峰度小于0表示该总体数据分布与正态分布相比较为平坦，为平顶峰。峰度的绝对值数值越大表示其分布形态的陡缓程度与正态分布的差异程度越大。<br>&emsp;&emsp;峰度的具体计算公式为：<br>&emsp;&emsp;<img src="http://images.51cto.com/files/uploadimg/20100408/161046770.jpg" alt="此处输入图片的描述"><br><br></p><h1 id="偏度（Skewness）"><a href="#偏度（Skewness）" class="headerlink" title="偏度（Skewness）"></a>偏度（Skewness）</h1><p>&emsp;&emsp;偏度与峰度类似，它也是描述数据分布形态的统计量，其描述的是某总体取值分布的对称性。这个统计量同样需要与正态分布相比较，偏度为0表示其数据分布形态与正态分布的偏斜程度相同；偏度大于0表示其数据分布形态与正态分布相比为正偏或右偏，即有一条长尾巴拖在右边，数据右端有较多的极端值；偏度小于0表示其数据分布形态与正态分布相比为负偏或左偏，即有一条长尾拖在左边，数据左端有较多的极端值。偏度的绝对值数值越大表示其分布形态的偏斜程度越大。<br>&emsp;&emsp;偏度的具体计算公式为：<br>&emsp;&emsp;<img src="http://images.51cto.com/files/uploadimg/20100408/161111811.jpg" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      介绍一下峰度（Kurtosis）和偏度（Skewness）的基本概念
    
    </summary>
    
      <category term="其他" scheme="https://pspxiaochen.club/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Kurtosis" scheme="https://pspxiaochen.club/tags/Kurtosis/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客撰写之：MarkDown语法介绍</title>
    <link href="https://pspxiaochen.club/2017-11-17-test/"/>
    <id>https://pspxiaochen.club/2017-11-17-test/</id>
    <published>2017-11-17T16:00:00.000Z</published>
    <updated>2017-11-20T08:03:16.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搭建好了hexo，接下来的就是写博客了， hexo 支持用 markdown 写博客，markdown 语法很简单，本文给出一些基本的 markdown 语法，结合 hexo 教你如何在 hexo 下用 markdown 撰写博客。</p><h1 id="hexo博客头部"><a href="#hexo博客头部" class="headerlink" title="hexo博客头部"></a>hexo博客头部</h1><pre><code>hexo 博客的 markdown 头部有固定的格式，如下所示：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo博客撰写之：MarkDown语法介绍</span><br><span class="line">date: 2017-11-17 09:12:00</span><br><span class="line">categories:</span><br><span class="line">  - 其他</span><br><span class="line">tags:</span><br><span class="line">  - hexo</span><br><span class="line">  - markdown</span><br><span class="line">description: 本文介绍如何在hexo搭建的博客下用markdown写文章,以及一些markdown的基本语法．</span><br><span class="line">photos:</span><br><span class="line">  - https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=62597ff6ba51f819e5280b18bbdd2188/908fa0ec08fa513d7ddc9503376d55fbb3fbd9fd.jpg</span><br></pre></td></tr></table></figure><p>顾名思义，我们很容易看懂这个头部信息．<br>我们写新博客的时候只需要复制这些内容，然后对相应的内容进行修改，但不要修改格式．</p><h1 id="hexo博客正文"><a href="#hexo博客正文" class="headerlink" title="hexo博客正文"></a>hexo博客正文</h1><pre><code>hexo 博客正文就是正常的 markdown 了，下面就介绍一些基本的 markdown 语法．</code></pre><h2 id="基本的markdown语法"><a href="#基本的markdown语法" class="headerlink" title="基本的markdown语法"></a>基本的markdown语法</h2><ul><li>标题<br>通过在行首插入 1 到 6 个 # ，来定义 1 到 6 阶 标题：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Markdown</th><th style="text-align:center">预览</th></tr></thead><tbody><tr><td style="text-align:center"><strong># 一级标题</strong></td><td style="text-align:center">#一级标题</td></tr><tr><td style="text-align:center"><strong>## 二级标题</strong></td><td style="text-align:center">## 二级标题</td></tr><tr><td style="text-align:center"><strong>### 三级标题</strong></td><td style="text-align:center">### 三级标题</td></tr></tbody></table></div><ul><li><p>段落和换行</p><p>  在 Markdown 中段落由一行或者多行文本组成，相邻的两行文字会被视为同一段落，如果存在空行则被视为不同段落( Markdown 对空行的定义是看起来是空行就是空行，即使空行中存在 空格 TAB 回车 等不可见字符，同样会被视为空行)。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">Markdown</th><th style="text-align:left">预览</th></tr></thead><tbody><tr><td style="text-align:left">第一行<br>相邻被视为统一段落</td><td style="text-align:left">第一行 相邻被视为同一段落</td></tr><tr><td style="text-align:left">第一行[空格][空格]<br>上一行结尾存在两个空格，段内换行</td><td style="text-align:left">第一行<br>上一行结尾存在两个空格，段内换行</td></tr><tr><td style="text-align:left">第一行<br><br>两行之间存在空行，视为不同段落。</td><td style="text-align:left">第一行<br><br>两行之间存在空行，视为不同段落。</td></tr></tbody></table></div><ul><li><p>缩进</p><p>输入法中文全角状态下输入两个空格即可实现缩进．输入两个<code>&amp;emsp;</code>或<code>&amp;ensp;</code>也可以实现空格缩进．</p></li><li><p>强调</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Markdown</th><th style="text-align:center">预览</th></tr></thead><tbody><tr><td style="text-align:center"><code>*倾斜*</code></td><td style="text-align:center"><em>倾斜</em></td></tr><tr><td style="text-align:center"><code>**粗体**</code></td><td style="text-align:center"><strong>粗体</strong></td></tr><tr><td style="text-align:center"><code>~~删除线~~</code></td><td style="text-align:center"><del>删除线</del></td></tr><tr><td style="text-align:center"><code>&gt;引用</code></td><td style="text-align:center">&gt;引用</td></tr></tbody></table></div><ul><li>连接和图片</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Markdown</th><th style="text-align:center">预览</th></tr></thead><tbody><tr><td style="text-align:center"><code>[百度一下](http://www.baidu.com)</code></td><td style="text-align:center"><a href="http://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">百度一下</a></td></tr><tr><td style="text-align:center"><code>![joker](https://timgsa.baidu.com/timg?image&amp;quality=80</code><br><code>&amp;size=b9999_10000&amp;sec=1511008391023&amp;di=1ff315398f4671c899</code><br><code>dc706aa34693de&amp;imgtype=0&amp;src=http%3A%2F%2Fimg3.duitang.com%2</code><br><code>Fuploads%2Fi</code><br><code>tem%2F201203%2F17%2F20120317230833_kvzj3.thumb.700_0.jpeg)</code></td><td style="text-align:center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1511008391023&amp;di=1ff315398f4671c899dc706aa34693de&amp;imgtype=0&amp;src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201203%2F17%2F20120317230833_kvzj3.thumb.700_0.jpeg" alt="joker"></td></tr></tbody></table></div><ul><li>音频和视频<br>可以直接使用html的 <audio> 和　<video> 标签嵌入　音频　和　视频．比如以下视频标签：<br><br><br>Markdown:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;center&gt;</span><br><span class="line"> &lt;video width=320 height=200      src=<span class="string">'http://tb-video.bdstatic.com/tieba-smallvideo/32_054ab95c5e7edd7a22c913fd1d1d8a5c.mp4'</span>  controls=<span class="string">'controls'</span> &gt; </span><br><span class="line"> 您的浏览器不支持 video 标签。 </span><br><span class="line">&lt;/video&gt;</span><br><span class="line">&lt;/center&gt;</span><br></pre></td></tr></table></figure></video></audio></li></ul><ul><li><p>列表</p><pre><code> 无序列表用 - 引领列表内容， 有序列表用　数字　引领列表内容， 需要指出的是：有序列表的数字即便不按照顺序排列，结果仍是有序的。</code></pre></li></ul><ul><li>下划线和特殊符号<pre><code> 由于 Markdown 使用一些特殊符号进行标记，当我们想要在文档中使用这些特殊符号并防止被 Markdown 转换的时候，可以使用 \ (转义符) 将这些特殊符号进行转义。</code></pre></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Markdown</th><th style="text-align:center">预览</th></tr></thead><tbody><tr><td style="text-align:center">在一行中用三个以上的减号来建立一个分隔线<br>—-</td><td style="text-align:center">—-</td></tr><tr><td style="text-align:center">可以利用反斜杠(转义字符)来插入一些在语法中有特殊意义的符号<br><code>\*Hi\*</code></td><td style="text-align:center">*Hi*</td></tr></tbody></table></div><ul><li><p>代码</p><p>1 行内代码<br>&emsp;行内代码可以使用反引号来标记(反引号一般位于键盘左上角，要用英文．</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Markdown</th><th style="text-align:center">预览</th></tr></thead><tbody><tr><td style="text-align:center">一句话`行内代码`一句话</td><td style="text-align:center">一句话<code>行内代码</code></td></tr><tr><td style="text-align:center">就比如` &lt; video &gt; `标签</td><td style="text-align:center">就比如<code>&lt; video &gt;</code>标签</td></tr></tbody></table></div><p>2 多行代码<br>&emsp;多行代码使用 3 个反引号来标记(反引号一般位于键盘左上角，要用英文) ，在第一个 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Markdown:</span><br><span class="line">``` javascript</span><br><span class="line">    ```javascript</span><br><span class="line">    // 我是注释</span><br><span class="line">    var a = 5 ;</span><br><span class="line">    console.log(a)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">预览：</span><br><span class="line">```javascript</span><br><span class="line">// 我是注释</span><br><span class="line">var a = 5 ;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure><ul><li>表格<br><strong>Markdown:</strong></li></ul><p>| 默认 | 靠右 | 居中 | 靠左 |<br>| —— | —-: | :—: | :—- |<br>| 内容 | 内容 | 内容 | 内容 |<br>| 内容 | 内容 | 条目 | 内容 |</p><p><strong>预览</strong></p><div class="table-container"><table><thead><tr><th>默认</th><th style="text-align:right">靠右</th><th style="text-align:center">居中</th><th style="text-align:left">靠左</th></tr></thead><tbody><tr><td>内容</td><td style="text-align:right">内容</td><td style="text-align:center">内容</td><td style="text-align:left">内容</td></tr><tr><td>内容</td><td style="text-align:right">内容</td><td style="text-align:center">条目</td><td style="text-align:left">内容</td></tr></tbody></table></div><hr><p>OK先到这里,基本语法就是这样，以后如果学到新的好用语法了，我会继续推送的^_^</p>]]></content>
    
    <summary type="html">
    
      本文介绍如何在hexo搭建的博客下用markdown写文章,以及一些markdown的基本语法．
    
    </summary>
    
      <category term="其他" scheme="https://pspxiaochen.club/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="markdown" scheme="https://pspxiaochen.club/tags/markdown/"/>
    
      <category term="hexo" scheme="https://pspxiaochen.club/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一篇post：庆祝博客搭建成功</title>
    <link href="https://pspxiaochen.club/2017-11-20-first-post/"/>
    <id>https://pspxiaochen.club/2017-11-20-first-post/</id>
    <published>2017-11-16T16:00:00.000Z</published>
    <updated>2017-11-20T02:30:36.777Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;&ensp;我听中文音乐很少，先放一首比较喜欢的中文歌曲… &emsp; 《平凡之路》—-朴树</p><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28815250&auto=0&height=66"></iframe><br></center><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;&ensp;一直想搭建自己的博客，但是一直没实践，只怪自己太懒。这次终于下定决心去实践，不过像我等小白来来回回折腾了好几天，本来想省点事直接在github上小改一下，谁知道老是出问题，一提交就收到Page build failure邮件，头疼的我差点放弃，最后狠下心来在本地安装了jekyll，一边调试一边修改，总算调通了，然后push到github，刷新主页，-_-，404找不到页面！妈呀，搜了好久解决办法，最后按照网上说的bundle update升级到了和github一样的最新版，这次报错了：MethedError：not find methed to_liquid for…想了半天，当前’github-pages’包的最新版是155,我把Gemfile中的’github-pages’改成了’github-pages’, ‘~&gt; 154’，也就是从默认的当前最新版本155降到了154,运行bundel exec jekyll serve，完美通过。。。我就郁闷了，原来这个jekyll-next主题已经不适用最新版的github-pages了。那怎么办呢，直接用hexo+next吧，索性静态页面就静态到底吧。</p><h1 id="安装node和hexo（基于windows）"><a href="#安装node和hexo（基于windows）" class="headerlink" title="安装node和hexo（基于windows）"></a>安装node和hexo（基于windows）</h1><ul><li><p>安装node<br>去nodejs官网下载32或者64位的 node 安装包，然后在Windows下安装 node ，安装完成后，添加 node 到系统 PATH 变量，然后 Win+r 打开运行窗口，输入 cmd 打开命令窗口，然后键入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>查看node是否已经安装好,再键入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure></li><li><p>安装Hexo<br>这里先安装cnpm，以加快npm包的下载速度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>然后，安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install hexo -g</span><br></pre></td></tr></table></figure><p>打开cmd命令窗口,键入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>查看hexo是否已安装好</p></li></ul><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>&emsp;&emsp;&ensp;去git for windows下载32或者64位的 git 安装包，然后在Windows下安装 git ，安装完成后，添加 git 到系统 PATH 变量，然后 Win+r 打开运行窗口，输入 cmd 打开命令窗口，然后键入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -v</span><br></pre></td></tr></table></figure></p><p>查看git是否已经安装好</p><h1 id="本地生成SSH-key并添加到github"><a href="#本地生成SSH-key并添加到github" class="headerlink" title="本地生成SSH key并添加到github"></a>本地生成SSH key并添加到github</h1><ul><li><p>本地生成ssh key<br>https每次push需要输入用户名和密码，为了以后部署方便，我们使用ssh提交，使用ssh需要配置添加SSH key，具体如下：<br>打开 git bash，输入以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ ssh-keygen -C <span class="string">"your_computer_name"</span></span><br></pre></td></tr></table></figure><p>接着会提示输入文件名，默认就行了，Enter<br>再接着会提示你输入两次密码，这个是push时候的密码，我们选择空密码，Enter<br>没问题的话就成功了。</p></li><li><p>添加ssh key 到github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后登录github，进入右上角Account Settings，然后点击菜单栏的SSH key进入页面添加key，<br>点击Add SSH key按钮，把复制的SSH key代码粘贴到key所对应的输入框，点击确认，Title会默认使用你的”your_computer_name”。</p></li><li><p>测试该SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Hi <span class="string">" your-github-username "</span>! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">$ Connection to github.com closed.</span></span><br></pre></td></tr></table></figure><p>ok,搞定。</p></li></ul><h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><ul><li><p>新建github pages仓库<br>注册github账号<br>然后新建一个仓库，仓库名称为 your-github-username.github.io，比如我的是pspxiaochen.github.io</p></li><li><p>搭建博客<br>在本地磁盘新建一个blog文件夹，比如在D盘新建一个blog文件夹，然后进入blog文件夹，执行以下操作：<br>右键打开 git bash，输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:spaceJmmy/spaceJmmy-blog-template</span><br><span class="line">$ <span class="built_in">cd</span> spaceJmmy-blog-template</span><br><span class="line">$ cnpm install</span><br></pre></td></tr></table></figure><p>下载完成后,继续输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>如果出现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop</span><br></pre></td></tr></table></figure><p>说明启动成功，但是信息还是我的，所以接下来要修改配置博客了。</p></li></ul><h1 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h1><h2 id="修改站点配置文件-spaceJmmy-blog-template-config-yml："><a href="#修改站点配置文件-spaceJmmy-blog-template-config-yml：" class="headerlink" title="修改站点配置文件 spaceJmmy-blog-template/_config.yml："></a>修改站点配置文件 spaceJmmy-blog-template/_config.yml：</h2><ul><li><p>修改站点信息，将以下内容改成你自己的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: spaceJmmy的博客 <span class="comment">#博客名</span></span><br><span class="line">subtitle: 纯真容易幸福，单纯就易满足 <span class="comment">#博客副标题</span></span><br><span class="line">description: <span class="comment">#给搜索引擎看的，对站点的描述，可以自定义</span></span><br><span class="line">author: spaceJmmy <span class="comment">#作者名称</span></span><br></pre></td></tr></table></figure></li><li><p>修改站点 URL ，将站点 URL 改成你自己的 URL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line">url: https://pspxiaochen.github.io</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure></li><li><p>修改部署备份信息：<br>把两个 git@github.com:spaceJmmy/spaceJmmy.github.io.git 换成成你自己的 repo 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line">deploy: </span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">      github: git@github.com:spaceJmmy/spaceJmmy.github.io.git,master</span><br><span class="line">  message: updated at &#123;&#123; now(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>) &#125;&#125; </span><br><span class="line">backup:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository:</span><br><span class="line">            github: git@github.com:spaceJmmy/spaceJmmy.github.io.git,src</span><br><span class="line">  message: updated at &#123;&#123; now(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>) &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改next主题配置文件-spaceJmmy-blog-template-themes-next-config-yml："><a href="#修改next主题配置文件-spaceJmmy-blog-template-themes-next-config-yml：" class="headerlink" title="修改next主题配置文件 spaceJmmy-blog-template/themes/next/_config.yml："></a>修改next主题配置文件 spaceJmmy-blog-template/themes/next/_config.yml：</h2><ul><li>修改 github 社交信息，将我的 GitHub 链接 <a href="https://github.com/spaceJmmy" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/spaceJmmy</a> 改成你自己的链接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  <span class="comment">#LinkLabel: Link</span></span><br><span class="line">  GitHub: https://github.com/spaceJmmy</span><br></pre></td></tr></table></figure></li></ul><h2 id="更换站点图标和用户头像："><a href="#更换站点图标和用户头像：" class="headerlink" title="更换站点图标和用户头像："></a>更换站点图标和用户头像：</h2><ul><li><p>更换站点图标<br>更换本地文件夹 spaceJmmy-blog-template/themes/next/source 下面的 favicon.ico ，换成你自己的站点图标，文件名不要改变。</p></li><li><p>更换用户头像<br>更换本地文件夹 spaceJmmy-blog-template/themes/next/source/images 下面的 avatar.gif ，换成你自己的用户头像，文件名不要改变。</p></li></ul><h2 id="修改关于页面："><a href="#修改关于页面：" class="headerlink" title="修改关于页面："></a>修改关于页面：</h2><p>  修改文件夹 spaceJmmy-blog-template/source/about 下的 index.md 文件，改为你自己的 关于 页面。</p><h2 id="测试配置是否成功"><a href="#测试配置是否成功" class="headerlink" title="测试配置是否成功"></a>测试配置是否成功</h2><p>  在git bash中输入以下命令：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p>  浏览器打开 <a href="http://localhost:4000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:4000/</a> ，如果成功的话，你会发现你的博客已经呈现出你的信息了，吼吼，狂欢吧…… 不过，先别急，先把网站部署备份了再说：</p><hr><p>  OK，接下来部署备份你的网站，这时候在 bash 终端 Ctrl+C 停止服务器运行，然后输入：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><p>  你会发现静态网站已经 push 到你 repo 的 master 分支了。浏览器打开 your-github-username.github.io 就能看到你的博客了，哈哈……<br>  继续，备份博客源码之前需要先删除当前目录下的 .git 文件夹，然后 bash　输入：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo b</span><br></pre></td></tr></table></figure></p><p>  你会发现网站源码已经备份到你 repo 的 src 分支了，至此，可以开心的庆祝啦，哈哈。</p><hr><h2 id="博客以后的常态化管理"><a href="#博客以后的常态化管理" class="headerlink" title="博客以后的常态化管理"></a>博客以后的常态化管理</h2><p>   以后写博客只需要自己写一个 .md 文件，然后放到/source/_posts文件夹下，写好博客后，来个拉风的部署三部曲，呼呼：<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment">#清空缓存</span></span><br><span class="line">$ hexo d <span class="comment">#部署站点到master分支</span></span><br><span class="line">$ hexo b <span class="comment">#备份站点源代码到src分支</span></span><br></pre></td></tr></table></figure></p><h2 id="换台电脑重新部署（记得添加新的SSH-key）"><a href="#换台电脑重新部署（记得添加新的SSH-key）" class="headerlink" title="换台电脑重新部署（记得添加新的SSH key）"></a>换台电脑重新部署（记得添加新的SSH key）</h2><p>   得益于前面的工作，换台电脑我们只需要clone仓库的src分支，然后重新生成hexo博客环境来撰写和发布post。<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b src git@github.com:your-github-username/your-github-username.github.io.git</span><br><span class="line">$ <span class="built_in">cd</span> your-github-username.github.io</span><br><span class="line">$ cnpm install</span><br></pre></td></tr></table></figure></p><p>   hexo环境搭建成功，然后 hexo s 本地预览，添加新的post，再按上述部署三部曲走起，呼呼…<br>   有时 hexo b 会报错，提示执行 git push，那就 git push，你会看到 push 成功，哈哈。</p><hr><p>&emsp;&emsp;&ensp;至此大功告成，看着自己现在这个博客上线，心里确实美滋滋啊，haha。</p><hr><p>&emsp;&emsp;&ensp;这个博客的搭建，要感谢很多人…</p><ul><li>首先感谢github，提供了git pages来托管我们的博客，而且是免费的;</li><li>然后要感谢提供主题模板的开源贡献者，使得像我这样的小白能够用上这么高大上的博客;</li><li>最后要感谢我自己，能够下定决心克服搭建博客的困难，谁让我是小白呢，慢慢进步。。。</li></ul>]]></content>
    
    <summary type="html">
    
      记录博客搭建过程和感受
    
    </summary>
    
      <category term="其他" scheme="https://pspxiaochen.club/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo" scheme="https://pspxiaochen.club/tags/hexo/"/>
    
      <category term="教程" scheme="https://pspxiaochen.club/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="node" scheme="https://pspxiaochen.club/tags/node/"/>
    
      <category term="git" scheme="https://pspxiaochen.club/tags/git/"/>
    
  </entry>
  
</feed>
